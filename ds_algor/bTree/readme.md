
## 基础知识点

平衡二叉树、红黑树的缺点：  
在数据量过大（没法一次性放入内存）的情况下，深度过大，导致磁盘读写过于频繁，查询效率低下。

磁盘读写时间 = 寻道时间 + 传输时间，寻道时间占大部分。读取时以盘块为单位，所以应尽量将相关的数据存放到同一盘块或磁道中，且一个盘块应尽量放足够多的索引数据，以减少 读块次数。

B树：平衡多路查找树，树高O(log N),插入、删除、查找的速率O(log N)。  
**注：log下是以 (m/2)为底**

**m阶B树的定义（摘自《编程之法-算法与面试心得》）：**  
1) 树中分支结点的孩子数 在[m/2, m]之间。  
2）树中根结点的孩子数 在[2, m]之间。  
3）每个分支结点的 关键字个数n在 [m/2-1, m-1]之间，有n+1个指向孩子的指针。  
4) 分支结点 既包含关键字（即索引数据），也包含实际的值（即索引对应的value）。
5）所有叶结点都在同一层。

**查询key操作：**  
从分支结点找到key所在区间的孩子结点，向下走，直到找到等于key的结点、或者 查询失败。  
注：每读取一个分支结点，都要载入一个磁盘块。在查找 key所在区间的孩子结点时，可用二分查找，以提高效率。

**插入(key,value)操作：**  
1）先判断这个key在B树中是否存在，如果不存在，则在`叶结点`中插入该元素。然后：  
2）若插入后 导致叶结点的关键字个数 超过m-1个，则进行`分裂`：  
将此结点分裂成两个结点（分裂的时候，value的指针也要相应移动），将中间的那个关键字上移到父结点。  
若 此时父结点的关键字个数 也超过了m-1个，则继续进行向上`分裂`。  
注：向上分裂导致根结点也分裂了，则会导致树的高度增加一层。

**删除key操作：**  
1) 先查找这个key在B树中是否存在，如果存在，则进行删除。  
若删除关键字的结点是分支结点，则`从子结点中借一个关键字`(即从左孩子、或者右孩子中找一个最接近key的关键字 移动到父结点)，value的指针也相应移动。  
若删除关键字的结点是叶子结点，则直接删除，value的指针也相应移动。  
2）若删除关键字后，某结点的关键字的个数小于m/2-1，则 看看 它左右兄弟结点是否丰满（即关键字个数超过m/2-1）：  
如果兄弟结点刚刚脱贫（都只有m/2-1个），则该结点与某一个兄弟结点**合并**（下移父结点的一个中间关键字，再合并）成一个结点。  
如果兄弟结点有一个比较丰满，则向父结点"借"一个关键字(然后 父结点向这个丰满的结点 借一个关键字)。  

**B+树与B的不同：**  
1）分支结点中只含有关键字，不存储实际的value。  
2）所有叶子结点 包含了所有的关键字信息、及实际的value，且叶子结点按关键字大小 升序链接起来。  
3）分支结点的孩子数 与 关键字个数 相同。  

**优点：**  
1. 分支结点只存 关键字信息 => 一个节点（一个节点存储在一个盘块中）可存储的关键字数量变多了 => 树的高度降低了 => 查询时 减少了磁盘I/O次数，速度更快。  
2. 查找操作必须走到叶子结点，才能取到真实数据。 => 查询效率更加稳定。  
3. 支持遍历操作，左右范围查询更加方便。  

## From toft

来自Google, 利用Btree实现的map/set，相比std::map/set(内部用红黑树实现)的优点：每个元素占用的空间更少，操作速度更快。  
但是B树在插入、删除时会导致 结点的分裂和合并，从而导致 之前保存的iterator无效。而std::map/set没这个问题。

实现代码中用了很多C++模板技巧，可读性不太好，没看懂。

## From JimDB

京东内部JimDB(redis的改造版)中B+的实现。

代码比较清晰，顺着流程，基本都能看懂。






